#+TITLE: ripgrep code review
# to get rid of the '_' subscript problem
#+OPTIONS: ^:{}

I've been playing around with [[https://www.rust-lang.org][Rust]] for a year and a half, and the best part of
it, like many others say, has been the very helpful community. There are a lot
of online resources that help you to get started: the [[https://doc.rust-lang.org/book/][Rust book]], the
[[https://doc.rust-lang.org/nomicon/][Rustonomicon]] and many [[https://this-week-in-rust.org/][blog posts]] and [[http://stackoverflow.com/questions/tagged/rust][stack overflow questions]]. After I learned
the basics I felt a bit lost though. I couldn't find enough resources for
intermediate-level-Rustaceans. I'm a C++ developer in my daily job, and so I'm
used with books like [[http://www.aristeia.com/books.html][Effective C++]] from Scott Meyers, the [[https://herbsutter.com/][Herb Sutter's blog]] and
a lot of online resources that always helped me with advanced C++ topics (that
are a lot... :sigh:). Those resources teach you how to get the best from the
language, how to use it properly, and how to structure your code to be more
clear and effective. Those resources are not completely absent in the Rust
community, but neither common.

How do you learn those things then? Well, there are two ways in my opinion: you
spend a lot of time and learn by doing, or you look at some good code. I think
code reviews are incredibly useful; you can see how other people reason about
problems you also struggled with, and how they have solved them. This post
attempts to target those intermediate-level-Rustaceans (like me), by looking at
the [[https://github.com/BurntSushi/ripgrep][ripgrep]] crate by Andrew Gallant, a great example of good Rust.

* Introduction
I'm not going to explain everything about the crate, since there is already a
very good [[http://blog.burntsushi.net/ripgrep/][blog post]] by Andrew himself, explaining how the application works from
a functional perspective, and some used algorithms. We are going instead to walk
through the crate architecture. I'm going to take for granted some of the
basics, so if you need a refresher you can take a look at the resources I
mentioned before.

We are going to look at this specific version of the crate:

#+BEGIN_EXAMPLE
  $ git describe
  0.2.5-4-gf728708
#+END_EXAMPLE

which is the last one at the time of writing. By the time you are reading this,
however, the crate might have evolved, so if you want to follow the code live,
you should checkout this specific version:

#+BEGIN_EXAMPLE
  $ git clone https://github.com/BurntSushi/ripgrep.git
  $ cd ripgrep
  $ git checkout f728708
#+END_EXAMPLE

and without further ado, let's get started.

* The big picture
~ripgrep~ is a command line tool for searching file contents using regular
expressions, similarly to GNU grep. The tool is split across four crates: the
main one (~ripgrep~), ~ignore~, ~grep~ and ~globset~.

[[file:crates.svg]]

The ~grep~ crate provides line-by-line regex searching from a buffer and it is
used only by the main crate. The ~globset~ crate uses regex to perform [[https://en.wikipedia.org/wiki/Glob_(programming)][glob
matching]] over paths. It is used by the main and the ~ignore~ crates. The
~ignore~ crate implements directory walking, ignore and include patterns. It
uses the ~glob~ crate for that. Finally, the main crate, which glues everything
together, implementing also command line argument parsing, output handling and
multi-threading.

One clear advantage of splitting an application in multiple crates is that it
forces you to keep your code scoped. It's easy to create a mess of dependencies
among the components if everything is in the same crate (or, even worse, in the
same module). If you instead take a part of your application and try to give it
a meaning by itself, you'll end up with a more generic, usable and clearer
interface. Embrace the [[https://en.wikipedia.org/wiki/Single_responsibility_principle][Single responsibility principle]] and let it be your guide.
This approach is clearly visible in ~ripgrep~.

* Main
Everything starts from the ~ripgrep~ main function:

#+CAPTION: ~main.rs:74~
#+BEGIN_SRC rust
  fn main() {
      match Args::parse().and_then(run) {
          Ok(count) if count == 0 => process::exit(1),
          Ok(_) => process::exit(0),
          Err(err) => {
              eprintln!("{}", err);
              process::exit(1);
          }
      }
  }
#+END_SRC

It is very concise: it parses the command line arguments and then pass them to
the ~run~ function. In between there is the [[https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then][Result::and_then]] combinator, so the
~match~ statement gets to the ~Ok~ branch only if both operations succeed. If
not, it selects the ~Err~ branch, handling errors for both the first and the
second operation. Then the exit code depends on whether there have been matches
or not.

#+CAPTION: ~main.rs:85~
#+BEGIN_SRC rust
  fn run(args: Args) -> Result<u64> {
      // ...
  }
#+END_SRC

The ~run~ function at first decides if it's worth to spawn threads or not, and
if so, this is the way it setups the things:

[[file:main.svg]]

The main thread, controlled by the ~run~ function digs files from the
filesystem, and pushes them into a [[https://crates.io/crates/deque][deque]]. This is a Single-producer /
Multiple-consumers queue, from which multiple worker threads can pull at the
same time. They will in turn perform the search operations. Here is the workers
initialization in the ~run~ function:

#+CAPTION: ~main.rs:116~
#+BEGIN_SRC rust
  let workq = {
      let (workq, stealer) = deque::new();
      for _ in 0..threads {
          let worker = MultiWorker {
              chan_work: stealer.clone(),
              // initialize other fields...
          };
          workers.push(thread::spawn(move || worker.run()));
      }
      workq
  };
#+END_SRC

As you can see, the ~deque::new()~ returns two objects. The queue is indeed
composed by two ends: one is the ~workq~ from which the main thread can push,
and the other end is the ~stealer~, from which all the workers can pull. Every
iteration of the loop creates a new worker and move it to a new thread, along
with a ~stealer~. Note that the ~stealer~ is [[https://doc.rust-lang.org/std/clone/trait.Clone.html][cloneable]], but this doesn't mean
that the queue itself is cloned. Internally indeed the ~stealer~ contains an [[https://doc.rust-lang.org/std/sync/struct.Arc.html][Arc]]
to the queue:

#+BEGIN_SRC rust
  pub struct Stealer<T: Send> {
      deque: Arc<Deque<T>>,
  }
#+END_SRC

To note here is the beauty of the ~deque~ interface. To express the fact that
the producer is only one, but the consumers can be multiple, the type is split
in two: the producer is then [[https://doc.rust-lang.org/std/marker/trait.Send.html][Send]] but not [[https://doc.rust-lang.org/std/marker/trait.Sync.html][Sync]], nor [[https://doc.rust-lang.org/std/clone/trait.Clone.html][Clone]]. There is no way to
use it from multiple threads, since you can yield the instance to another
thread, but in that case you can't keep another reference to it. The ~Stealer~,
which is the other end, is instead both ~Send~ and ~Clone~. You can then pass
them around by cloning and sending them off to other threads. They can all be
used as they refer to the same queue. There is no way to use this interface
incorrectly.

Another thing to note here is that the ~workq~ variable is initialized by a
block, that returns just the producer part of a new ~deque~. Inside the block,
the workers along with their stealers are moved into new worker threads and
those are in turn pushed into a vector. Using a block that just returns what
it's needed for the rest of the function is a good practice. In this way the
~run~ function is not polluted with variables that are not usable anymore
because their values have been moved.

This is the ~MultiWorker~ struct, that runs in a separate thread:

#+CAPTION: ~main.rs:236~
#+BEGIN_SRC rust
  struct MultiWorker {
      chan_work: Stealer<Work>,
      quiet_matched: QuietMatched,
      out: Arc<Mutex<Out>>,
      #[cfg(not(windows))]
      outbuf: Option<ColoredTerminal<term::TerminfoTerminal<Vec<u8>>>>,
      #[cfg(windows)]
      outbuf: Option<ColoredTerminal<WindowsBuffer>>,
      worker: Worker,
  }
#+END_SRC

the first field is the stealer. As you can see from its type, the stealer
receives ~Work~ structs:

#+CAPTION: ~main.rs:225~
#+BEGIN_SRC rust
  enum Work {
      Stdin,
      File(DirEntry),
      Quit,
  }
#+END_SRC

The main thread will push them from its ~workq~ variable:

#+CAPTION: ~main.rs:136~
#+BEGIN_SRC rust
  for dent in args.walker() {
      if quiet_matched.has_match() {
          break;
      }
      paths_searched += 1;
      if dent.is_stdin() {
          workq.push(Work::Stdin);
      } else {
          workq.push(Work::File(dent));
      }
  }
#+END_SRC

The ~args.walker()~ is an iterator over the files to search, or the standard
input stream, if the ~-~ argument is passed. In the former case it pushes a
~Work::File~ entry with the path, in the latter a ~Work::Stdin~ entry.

The ~MultiWorker::run~ function is a loop that pops items from the ~deque~ and
process them one by one:

#+CAPTION: ~main.rs:256~
#+BEGIN_SRC rust
  loop {
      if self.quiet_matched.has_match() {
          break;
      }
      let work = match self.chan_work.steal() {
          Stolen::Empty | Stolen::Abort => continue,
          Stolen::Data(Work::Quit) => break,
          Stolen::Data(Work::Stdin) => WorkReady::Stdin,
          Stolen::Data(Work::File(ent)) => {
              match File::open(ent.path()) {
                  Ok(file) => WorkReady::DirFile(ent, file),
                  Err(err) => {
                      eprintln!("{}: {}", ent.path().display(), err);
                      continue;
                  }
              }
          }
      };
      // ...
  }
#+END_SRC

The ~steal()~ method tries to pop from the ~deque~ and returns a ~Stolen~
instance:

#+BEGIN_SRC rust
  pub enum Stolen<T> {
      /// The deque was empty at the time of stealing
      Empty,
      /// The stealer lost the race for stealing data, and a retry may return more
      /// data.
      Abort,
      /// The stealer has successfully stolen some data.
      Data(T),
  }
#+END_SRC

The outcome is matched against the different possibilities, but only
~Stolen::Data~ contains a ~Work~ entry. Both ~Stdin~ and ~File~ entry types are
then translated into a ~WorkReady~ instance. In the second case the file is then
opened with an ~std::fs::File~. The ~work~ variable is later consumed by a
~Worker~ instance:

#+CAPTION: ~main.rs:277~
#+BEGIN_SRC rust
  self.worker.do_work(&mut printer, work);
#+END_SRC

We'll get back to that in a moment, but let's first backtrack to the
~MultiWorker::run~ loop. The ~Work::Quit~ case breaks it, so the thread
terminates:

#+CAPTION: ~main.rs:262~
#+BEGIN_SRC rust
  let work = match self.chan_work.steal() {
      // ...
      Stolen::Data(Work::Quit) => break,
      // ...
#+END_SRC

This value is pushed by the main thread when all the files have been examined:

#+CAPTION: ~main.rs:152~
#+BEGIN_SRC rust
  for _ in 0..workers.len() {
      workq.push(Work::Quit);
  }
  let mut match_count = 0;
  for worker in workers {
      match_count += worker.join().unwrap();
  }
#+END_SRC

The threads are all guaranteed to terminate because the number of ~Quit~
messages pushed is the same as the number of workers. A worker can only consume
one of them and then quit. This implies that, since no messages can be lost, all
the workers will get the message at some point and then terminate. All the
workers threads are then joined, waiting for completion.

This is a good multi-threading pattern to follow:
+ a ~deque~ in between a producer (that provides the workloads) and a bunch of
  consumers (that do the heavy lifting) in separate threads;
+ the ~deque~ carries an enumeration of the things to do, and one of them is the
  ~Quit~ action;
+ the producer will eventually push a bunch of ~Quit~ messages to terminate the
  worker threads (one per thread).

In case you just have one type of job, it makes perfect sense to use an
~Option<Stuff>~ as work item, instead of an enumeration. The workers will have
to terminate in case ~None~ is passed. The ~Option~ can be used also in the
~ripgrep~ case, replacing the ~Quit~ message but I'm not sure the code would be
more readable:

#+BEGIN_SRC rust
  let work = match self.chan_work.steal() {
      Stolen::Empty | Stolen::Abort => continue,
      Stolen::Data(None) => break,
      Stolen::Data(Some(Work::Stdin)) => WorkReady::Stdin,
      Stolen::Data(Some(Work::File(ent)) => {
          // ...
      }
  };
#+END_SRC

This was the multi-threading operational mode. ~ripgrep~ can however operate in
a single thread, in case there is only one file to search or only one core to
use, or the user says so. The ~run~ function checks that:

#+CAPTION: ~main.rs:100~
#+BEGIN_SRC rust
  let threads = cmp::max(1, args.threads() - 1);
  let isone =
      paths.len() == 1 && (paths[0] == Path::new("-") || paths[0].is_file());
  // ...
  if threads == 1 || isone {
      return run_one_thread(args.clone());
  }
#+END_SRC

and calls the ~run_one_thread~ function for the single-threaded case (I have
removed some uninteresting details):

#+CAPTION: ~main.rs:162~
#+BEGIN_SRC rust
  fn run_one_thread(args: Arc<Args>) -> Result<u64> {
      let mut worker = Worker {
          args: args.clone(),
          inpbuf: args.input_buffer(),
          grep: args.grep(),
          match_count: 0,
      };
      // ...
      for dent in args.walker() {
          // ...
          if dent.is_stdin() {
              worker.do_work(&mut printer, WorkReady::Stdin);
          } else {
              let file = match File::open(dent.path()) {
                  Ok(file) => file,
                  Err(err) => {
                      eprintln!("{}: {}", dent.path().display(), err);
                      continue;
                  }
              };
              worker.do_work(&mut printer, WorkReady::DirFile(dent, file));
          }
      }
      // ...
  }
#+END_SRC

As you can see, the function uses a single ~Worker~. If you remember, this
struct is also used by ~MultiWorker~. The files to search are iterated by
~args.walker()~ as before, and each entry is passed to the ~worker~, as before.
The use of ~Worker~ in both cases allows code reuse to a great extent.

* The file listing
We are now going to look over the file listing functional block.

The default operation mode of ~ripgrep~ is to search recursively for non-binary,
non-ignored files starting from the current directory (or from the given paths).
To enumerate the files and feed the search engine, ~ripgrep~ uses the ~ignore~
crate.

But let's start from the beginning. The ~walker~ function provided by ~Args~ and
used by the ~run~ function in ~main~, returns a ~Walk~ struct:

#+CAPTION: ~args.rs:725~
#+BEGIN_SRC rust
  pub fn walker(&self) -> Walk;
#+END_SRC

~Walk~ is just a simple wrapper around the ~ignore::Walk~ struct. A value of
this struct can be created by using its ~new~ method:

#+CAPTION: ~walk.rs:261~
#+BEGIN_SRC rust
  pub fn new<P: AsRef<Path>>(path: P) -> Walk;
#+END_SRC

or with a ~WalkBuilder~, that implements the [[https://doc.rust-lang.org/book/method-syntax.html#builder-pattern][builder pattern]]. This allows to
customize the behavior without annoying the user, and not to force them to
provide a lot of parameters to the constructor:

#+BEGIN_SRC rust
  let w = WalkBuilder::new(path).ignore(true).max_depth(Some(5)).build();
#+END_SRC

In this example we have created a ~WalkBuilder~ with default arguments and just
override the ~ignore~ and ~max_depth~ options.

The implementation of the type is not very interesting from our point of view.
It is basically an ~Iterator~ that walks through the filesystem by using the
~walkdir~ crate, but ignores the files and directories listed in ~.gitignore~
and ~.ignore~ files possibly present, with the help of the ~Ignore~ type. We'll
look at that type a bit later. Let's look at the ~Error~ type first:

#+CAPTION: ~ignore/src/lib.rs:74~
#+BEGIN_SRC rust
  /// Represents an error that can occur when parsing a gitignore file.
  #[derive(Debug)]
  pub enum Error {
      Partial(Vec<Error>),
      WithLineNumber { line: u64, err: Box<Error> },
      WithPath { path: PathBuf, err: Box<Error> },
      Io(io::Error),
      Glob(String),
      UnrecognizedFileType(String),
      InvalidDefinition,
  }
#+END_SRC

This error type has an interesting recursive definition. The ~Partial~ case of
the enumeration contains a vector of ~Error~ instances, for example.
~WithLineNumber~ adds line information to an ~Error~. In this case ~Box<Error>~,
since a recursive type cannot embed itself, otherwise it would be impossible to
compute the size of the type.

Then the [[https://doc.rust-lang.org/std/error/trait.Error.html][error::Error]], [[https://doc.rust-lang.org/std/fmt/trait.Display.html][fmt::Display]] and [[https://doc.rust-lang.org/std/convert/trait.From.html][From<io::Error>]] traits are implemented,
to make it a proper error type and to easily construct it out an ~io::Error~.
Here, the boilerplate necessary to crank up the error type are handcrafted.
Another possibility could have been to use the [[https://github.com/tailhook/quick-error][quick-error]] macro, which reduces
the burden to implement error types to a minimum. You can find a good reference
on the error handling topic in [[https://doc.rust-lang.org/stable/book/error-handling.html][the Rust book]].

** Ignore patterns
Ignore patterns are handled within the ~ignore~ crate by the ~Ignore~ struct.
This type connects directory traversal with ignore semantics. In practice it
builds a tree-like structure that mimics the directories structure, in which
leaves are new ignore contexts. The implementation is quite complicated, but
let's give it a brief look:

#+CAPTION: ~ignore/src/dir.rs:84~
#+BEGIN_SRC rust
  #[derive(Clone, Debug)]
  pub struct Ignore(Arc<IgnoreInner>);

  #[derive(Clone, Debug)]
  struct IgnoreInner {
      compiled: Arc<RwLock<HashMap<OsString, Ignore>>>,
      dir: PathBuf,
      overrides: Arc<Override>,
      types: Arc<Types>,
      parent: Option<Ignore>,
      is_absolute_parent: bool,
      absolute_base: Option<Arc<PathBuf>>,
      explicit_ignores: Arc<Vec<Gitignore>>,
      ignore_matcher: Gitignore,
      git_global_matcher: Arc<Gitignore>,
      git_ignore_matcher: Gitignore,
      git_exclude_matcher: Gitignore,
      has_git: bool,
      opts: IgnoreOptions,
  }
#+END_SRC

Please note that I have taken out the comments to make it shorter. The ~Ignore~
struct is a wrapper around an atomic reference counter to the actual data
(namely, the ~IgnoreInner~). A first interesting field inside that struct is
~parent~, that is an ~Option<Ignore>~. It points to a parent entry if present.
So, this is where the tree structure comes from: the ~Arc~ can be shared, so
multiple ~Ignore~ can share the same parent. But that's not all; they can also
be cached in the ~compiled~ field, that has a quite complex type:

#+BEGIN_SRC rust
  Arc<RwLock<HashMap<OsString, Ignore>>>
#+END_SRC

This is the cache of ~Ignore~ instances that is shared among all of them.
Let's try to break it down:
+ the ~HashMap~ maps paths to ~Ignore~ instances (as expected);
+ the ~RwLock~ allows the map to be shared and modified across different
  threads, without causing data races;
+ and finally the ~Arc~ allow the cache to be owned safely by different owners
  in different threads.

Every time a new ~Ignore~ instance has to be built and added to a tree, the
implementation first looks in the cache, trying to reuse the existing instances.
The tree is built dynamically, while crawling the directories, looking for the
specific ignore files (e.g. ~.gitignore~, ~.ignore~, ~.rgignore~). Other ignore
patterns can be manually added from the command line, and are also added to the tree.

Another interesting bit here is the ~add_parents~ signature for ~Ignore~:

#+CAPTION: ~ignore/src/dir.rs:149~
#+BEGIN_SRC rust
  pub fn add_parents<P: AsRef<Path>>(&self, path: P) -> (Ignore, Option<Error>);
#+END_SRC

Instead of returning a ~Result<Ignore, Error>~, it returns a pair, that contains
always a result and optionally an error. In this way partial failures are
allowed. If you remember, the error can also be a vector of errors, so the
function can collect them while working, but then it can also return a (maybe
partial) result in the end. I found this approach very interesting.

* The search process
In this section we will look at how the regex search inside a file is
implemented. This process involves some modules in ~ripgrep~ and also the ~grep~
crate.

Everything starts from ~Worker::do_work~ in ~main.rs~. Based on the type of the
file passed in, ~search~ or ~search_mmap~ are in turn called. The first function
is used to read the input one chunk at a time and then search, while the second
is used to search into a memory mapped input. In this case there is no need to
read the file into a buffer, because it is already available in memory, or more
precisely, the kernel will take care of this illusion.

The ~search~ function just creates a new ~Searcher~ and calls ~run~ on it.

#+CAPTION: ~search_stream.rs:224~
#+BEGIN_SRC rust
  impl<'a, R: io::Read, W: Terminal + Send> Searcher<'a, R, W> {
      pub fn run(mut self) -> Result<u64, Error>;
  }
#+END_SRC

The first interesting thing to note here is that the ~run~ function actually
consumes ~self~, so you can't actually run the method twice. Why is that? Let's
have a look at the ~new~ method, that creates this struct:

#+CAPTION: ~search_stream.rs:135~
#+BEGIN_SRC rust
  impl<'a, R: io::Read, W: Terminal + Send> Searcher<'a, R, W> {
      pub fn new(inp: &'a mut InputBuffer,
                 printer: &'a mut Printer<W>,
                 grep: &'a Grep,
                 path: &'a Path,
                 haystack: R) -> Searcher<'a, R, W>;
  }
#+END_SRC

It takes a bunch of arguments and stores them into a new ~Searcher~ instance.
All the arguments to ~Searcher~ are passed as reference, except ~haystack~ which
is the ~Read~ stream representing the file. This means that when this struct
will be destroyed, the file will be gone. Whenever you complete the search for a
file, you don't have to do it again, indeed. You can enforce this usage by
consuming the input file in the ~run~ function, or take its ownership in the
constructor and force the ~run~ function to consume ~self~.

Since we cannot run the search twice using the same ~Searcher~ instance, why
don't we just use a function then? The approach used here has several
advantages:

1. you get the behavior that the search cannot be run twice with the same file
   (but that's nothing that a free function could not do);
2. you can split the function among different private functions, without passing
   around all the arguments; they will all take ~self~ by reference (maybe also
   ~&mut self~) and just use the member variables.

So, instead of:

#+BEGIN_SRC rust
  fn helper1(inp: &mut InputBuffer,
             printer: &mut Printer<W>,
             grep: &Grep,
             path: &Path,
             haystack: &mut R)
  {
      // do something with path, grep, etc
  }
#+END_SRC

we have:

#+BEGIN_SRC rust
  fn helper1(&mut self) {
      // do something with self.path, self.grep, etc
  }
#+END_SRC

The end result is much nicer.

The first variable that the ~Searcher~ takes is an ~InputBuffer~. It is defined
in the ~search_stream~ module too, and provides buffering for the input file. It
has the interesting feature to be able to keep part of the data across reads.
This is needed, for example, when the user requests context lines, or when a
single read is not enough to reach the next end of line.

The ~fill~ function in the ~InputBuffer~, reads from the input and optionally
rolls over the contents of the buffer starting from the ~keep_from~ index:

#+CAPTION: ~search_stream.rs:521~
#+BEGIN_SRC rust
  fn fill<R: io::Read>(&mut self, rdr: &mut R, keep_from: usize) -> Result<bool, io::Error>;
#+END_SRC

The interesting implementation bit here is that the buffer grows whenever it
needs more room, but it never shrinks. This avoids some re-allocations, at the
expense of some memory. This approach is perfectly fine in this case, since the
application is intended to work in one shot and then terminate. In a long
running application such as a webserver, this is probably not what you want to
do.

After the buffer has been filled, the ~Grep~ matcher is run, and in case of a
match, it prints the results, according to the options (context lines, line
numbers, etc.).

Note that ~Searcher~ takes the input buffer by mutable reference. This means
that it can be reused for the next file, without allocating new memory for the
buffer, with a new ~Searcher~ instance.

I'll skip most of the implementation review, even if the code may be
interesting. Most of it however is just implementation detail that is not very
relevant outside this specific case. If you are interesting you can skim through
the ~search_stream~ module code.

The ~search_mmap~ function, instead, creates a ~BufferSearcher~, defined in the
~search_buffer~ module, and calls run on it, like in the ~Searcher~ case:

#+CAPTION: ~search_buffer.rs:98~
#+BEGIN_SRC rust
  impl<'a, W: Send + Terminal> BufferSearcher<'a, W> {
      pub fn run(mut self) -> u64;
  }
#+END_SRC

The same reasoning applies here: the struct is created and used only once for
one file, because the ~run~ function takes ~self~ by value. The purpose of the
~search_buffer~ module is to search inside a file completely contained in a
single buffer, instead of a stream. This buffer is provided by a memory mapped
file, and it's used only when a stream would be slower (generally this happens
when searching into a single huge file). This module reuses some types provided
by the ~search_stream~ module:

#+CAPTION: ~search_buffer.rs:16~
#+BEGIN_SRC rust
  use search_stream::{IterLines, Options, count_lines, is_binary};
#+END_SRC

Notably, it does not use the ~InputBuffer~, since there is nothing to buffer
here: everything is already available in the input buffer. The implementation is
very basic, and it doesn't support some of the features the other module does
(like showing context lines).

No big surprises here. The only minor weak point for me is that this module
depends on the ~search_stream~ one. It doesn't actually build on top of it, but
it just imports some functionality. I'd rather try to move the common
implementation in another module from which they can both import. This makes
sense, since the common stuff is indeed not specific to either of the modules.

** The grep crate

The ~grep~ crate provides all you need to regex search into a line. It builds on
top of the [[https://doc.rust-lang.org/regex/regex/index.html][Rust regex]] crate, and adds some optimizations in the ~literal~
module. The result of a search is a ~Match~ instance, which is simply a position
inside that buffer:

#+CAPTION: ~grep/src/search.rs:12~
#+BEGIN_SRC rust
  #[derive(Clone, Debug, Default, Eq, PartialEq)]
  pub struct Match {
      start: usize,
      end: usize,
  }
#+END_SRC

The ~Grep~ type is cloneable. This is important, since it can be built once
(which is an expensive operation) and then cloned to all the worker threads:

#+CAPTION: ~grep/src/search.rs:38~
#+BEGIN_SRC rust
  #[derive(Clone, Debug)]
  pub struct Grep {
      re: Regex,
      required: Option<Regex>,
      opts: Options,
  }
#+END_SRC

I won't dig into the implementation details, since they are already very well
covered in the already mentioned [[http://blog.burntsushi.net/ripgrep/][Andrew's blog post]].

* Output handling
The last bit we are going to investigate now is the output handling. The
challenge here is that ~ripgrep~ needs to write from multiple threads to a
single console without interleaving the results.

Here is how the ~run~ function in our ~MultiWorker~ handles that:

#+CAPTION: ~main.rs:274~
#+BEGIN_SRC rust
  let mut outbuf = self.outbuf.take().unwrap();
  outbuf.clear();
  let mut printer = self.worker.args.printer(outbuf);
  self.worker.do_work(&mut printer, work);
  // ...
  let outbuf = printer.into_inner();
  if !outbuf.get_ref().is_empty() {
      let mut out = self.out.lock().unwrap();
      out.write(&outbuf);
  }
  self.outbuf = Some(outbuf);
#+END_SRC

An output buffer is taken from ~self~ and passed to a printer. The printer is
then passed to the worker, that uses it to print the results. So far all the
output went to the buffer, and not to the actual console. Then, if anything has
been buffered, lock the output and write everything. The output buffer is reused
in this interesting way: it is kept as an ~Option~ field inside the
~MultiWorker~ itself. For every file, it is then moved away from the option,
passed by value to a ~Printer~, and then when the ~Printer~ is done, put it back
in the ~Option~. This allows to keep it mutable and pass it around by value
without creating it every time.

The trick used here, to avoid to interleave the prints, is to buffer all the
matches found in a file into a "virtual terminal" that doesn't print to the
console. After the search in that file is done, the output is written in one
shot, by locking a shared ~Out~ object and write the buffer contents to the
actual console.

[[file:out.svg]]

Let's take a look at the various types involved. The ~MultiWorker~ keeps a
~ColoredTerminal~ instance in its ~self.outbuf~ field. Its type depends on the
platform:

#+BEGIN_SRC rust
  #[cfg(not(windows))]
  outbuf: Option<ColoredTerminal<term::TerminfoTerminal<Vec<u8>>>>,
  #[cfg(windows)]
  outbuf: Option<ColoredTerminal<WindowsBuffer>>,
#+END_SRC

The ~self.out~ is the same in all the platforms:

#+BEGIN_SRC rust
  let out: Arc<Mutex<Out>>;
#+END_SRC

As you can see, it can be shared and mutated by multiple threads, because it is
wrapped in a ~Mutex~ and an ~Arc~.

Inside an ~Out~ instance, there is the terminal used to write directly to the
console:

#+BEGIN_SRC rust
  #[cfg(not(windows))]
  let term: ColoredTerminal<term::TerminfoTerminal<io::BufWriter<io::Stdout>>>;
  #[cfg(windows)]
  let term: ColoredTerminal<WinConsole<io::Stdout>>;
#+END_SRC

A ~ColoredTerminal~ that refers to a ~TerminfoTerminal~ on Linux, and to a
~WinConsole~ on Windows. They are both structs defined in the [[https://crates.io/crates/term][term crate]].

But let's step back a little bit and describe all these types a little bit
better. The ~Searcher~, uses a ~Printer~, whenever a match is found (and the
output is enabled). The ~Printer~ is defined in the ~printer~ module and it
encapsulates the general output logic. It knows how to print a match, given some
options, and forwards the writes to an inner ~Terminal~ type.

#+CAPTION: ~printer.rs:15~
#+BEGIN_SRC rust
  pub struct Printer<W> {
      wtr: W,
      has_printed: bool,
      column: bool,
      context_separator: Vec<u8>,
      eol: u8,
      file_separator: Option<Vec<u8>>,
      heading: bool,
      line_per_match: bool,
      null: bool,
      replace: Option<Vec<u8>>,
      with_filename: bool,
      color_choice: ColorChoice
  }
#+END_SRC

Note that I took the comments out to make it shorter. As you can see, there is a
generic writer ~W~ that is taken by value and a lot of other options. This
generic parameter is expected to implement [[https://docs.rs/term/0.4.4/term/trait.Terminal.html][~term::Terminal~]] and ~Send~, as you
can see in the struct implementation:

#+CAPTION: ~printer.rs:73~
#+BEGIN_SRC rust
  impl<W: Terminal + Send> Printer<W> {
      // printer implementation
  }
#+END_SRC

The struct uses the builder pattern again, but with a slightly different flavor.
The ~new~ method takes only a ~Terminal~ and sets all the options with a default
value. To change them, the user needs to call the various builder methods,
directly on the ~Printer~ itself, not on another builder helper. For example:

#+CAPTION: ~printer.rs:121~
#+BEGIN_SRC rust
  pub fn heading(mut self, yes: bool) -> Printer<W> {
      self.heading = yes;
      self
  }
#+END_SRC

takes ~self~ by mutable value and, after changing the ~heading~ option, returns
~self~ by value again.

The implementation is simple. The public interface provides some methods to
print the various match components, like the path, the context separator and the
line contents. The only thing that is still not clear to me is why the ~Send~
trait is also needed, since I don't see any threading in the struct
implementation, and all the print methods require a mutable ~self~, e.g.:

#+CAPTION: ~printer.rs:207~
#+BEGIN_SRC rust
  pub fn context_separate(&mut self) {
      // N.B. We can't use `write` here because of borrowing restrictions.
      if self.context_separator.is_empty() {
          return;
      }
      self.has_printed = true;
      let _ = self.wtr.write_all(&self.context_separator);
      let _ = self.wtr.write_all(&[self.eol]);
  }
#+END_SRC

In any case, the implementation is more or less straight forward, and in the end
all the writes are directed to the inner ~Terminal~.

In the Linux case, the ~Terminal~ is the default one provided by the ~term~
crate itself: [[https://docs.rs/term/0.4.4/term/terminfo/struct.TerminfoTerminal.html][~TerminfoTerminal~]]. On Windows ~ripgrep~ provides a custom
implementation, since the coloring needs a special treatment, to avoid
performance hurt:

#+CAPTION: ~terminal_win.rs:5~
#+BEGIN_SRC text
  This particular implementation is a bit idiosyncratic, and the "in-memory"
  specification is to blame. In particular, on Windows, coloring requires
  communicating with the console synchronously as data is written to stdout.
  This is anathema to how ripgrep fundamentally works: by writing search results
  to intermediate thread local buffers in order to maximize parallelism.

  Eliminating parallelism on Windows isn't an option, because that would negate
  a tremendous performance benefit just for coloring.

  We've worked around this by providing an implementation of `term::Terminal`
  that records precisely where a color or a reset should be invoked, according
  to a byte offset in the in memory buffer. When the buffer is actually printed,
  we copy the bytes from the buffer to stdout incrementally while invoking the
  corresponding console APIs for coloring at the right location.
#+END_SRC

The implementation is provided by ~WindowsBuffer~:

#+CAPTION: ~terminal_win.rs:33~
#+BEGIN_SRC rust
  /// An in-memory buffer that provides Windows console coloring.
  #[derive(Clone, Debug)]
  pub struct WindowsBuffer {
      buf: Vec<u8>,
      pos: usize,
      colors: Vec<WindowsColor>,
  }

  /// A color associated with a particular location in a buffer.
  #[derive(Clone, Debug)]
  struct WindowsColor {
      pos: usize,
      opt: WindowsOption,
  }

  /// A color or reset directive that can be translated into an instruction to
  /// the Windows console.
  #[derive(Clone, Debug)]
  enum WindowsOption {
      Foreground(Color),
      Background(Color),
      Reset,
  }
#+END_SRC

This struct implements ~terminfo::Terminal~ as we said before, and it contains a
buffer of characters to print, a position on the buffer itself, and a vector of
colors and positions. Whenever something has to be print, and the write is
called, the output is buffered in ~self.buf~:

#+CAPTION: ~terminal_win.rs:107~
#+BEGIN_SRC rust
  impl io::Write for WindowsBuffer {
      fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
          let n = try!(self.buf.write(buf));
          self.pos += n;
          Ok(n)
      }

      fn flush(&mut self) -> io::Result<()> {
          Ok(())
      }
  }
#+END_SRC

and whenever a coloring option is passed, it is pushed into the ~colors~ vector,
along with the current position:

#+CAPTION: ~terminal_win.rs:119~
#+BEGIN_SRC rust
  impl Terminal for WindowsBuffer {
      type Output = Vec<u8>;

      fn fg(&mut self, fg: Color) -> term::Result<()> {
          self.push(WindowsOption::Foreground(fg));
          Ok(())
      }
      // ...
  }
#+END_SRC

Then, when the higher level logic decides it's time to print everything, the
~print_stdout~ is called, passing another terminal (the real one, linked with
the console):

#+CAPTION: ~terminal_win.rs:72~
#+BEGIN_SRC rust
  /// Print the contents to the given terminal.
  pub fn print_stdout<T: Terminal + Send>(&self, tt: &mut T) {
      if !tt.supports_color() {
          let _ = tt.write_all(&self.buf);
          let _ = tt.flush();
          return;
      }
      let mut last = 0;
      for col in &self.colors {
          let _ = tt.write_all(&self.buf[last..col.pos]);
          match col.opt {
              WindowsOption::Foreground(c) => {
                  let _ = tt.fg(c);
              }
              WindowsOption::Background(c) => {
                  let _ = tt.bg(c);
              }
              WindowsOption::Reset => {
                  let _ = tt.reset();
              }
          }
          last = col.pos;
      }
      let _ = tt.write_all(&self.buf[last..]);
      let _ = tt.flush();
  }
#+END_SRC

Here, if the terminal does not support coloring, there is nothing special to do,
and all the buffer contents are written. Otherwise, for every color option, it
writes the buffer contents before that option location, and than applies the
option. This is repeated until the end of the buffer.

The terminal is not used as is by the higher level logic, but wrapped inside a
~ColoredTerminal~ instance:

#+CAPTION: ~out.rs:111~
#+BEGIN_SRC rust
  #[derive(Clone, Debug)]
  pub enum ColoredTerminal<T: Terminal + Send> {
      Colored(T),
      NoColor(T::Output),
  }
#+END_SRC

The purpose of this type is simple: determine if the current terminal supports
coloring, and if so use it. If not, just drop the terminal and use its internal
writer type. Determine color support is a costly operation, so it's done only
once, and the result is cached in a static variable, with the help of the
[[mhe:%0A][lazy_static]] crate:

#+CAPTION: ~out.rs:123~
#+BEGIN_SRC rust
  lazy_static! {
      // Only pay for parsing the terminfo once.
      static ref TERMINFO: Option<TermInfo> = {
          match TermInfo::from_env() {
              Ok(info) => Some(info),
              Err(err) => {
                  debug!("error loading terminfo for coloring: {}", err);
                  None
              }
          }
      };
  }
#+END_SRC

The type then implements some specialized constructors for a bunch of types:
+ ~WindowsBuffer~;
+ ~WinConsole<io::Stdout>~;
+ and the one for the generic writer ~W: io::Write + Send~.

If the terminal then supports coloring, the ~Colored(T)~ enum value (where ~T~
is ~T: Terminal + Send~) is used. In this case the ~ColoredTerminal~ instance
contains a ~Terminal~. Otherwise, the ~NoColor(T::Output)~ value is selected,
using then only a plain ~io::Write~. ~ColoredTerminal~ then implements
~Terminal~ itself in this way:

#+CAPTION: ~out.rs:254~
#+BEGIN_SRC rust
  impl<T: Terminal + Send> term::Terminal for ColoredTerminal<T> {
      type Output = T::Output;

      fn fg(&mut self, fg: term::color::Color) -> term::Result<()> {
          self.map_result(|w| w.fg(fg))
      }
      // other very similar implementations...
  }

#+END_SRC

The intended behavior here is to forward the function to the inner terminal, if
present, or return an error otherwise. A possible solution would have been to
~match self~ in this way:

#+BEGIN_SRC rust
  match *self {
      ColoredTerminal::Colored(ref mut w) => w.fg(fg),
      ColoredTerminal::NoColor(_) => Err(term::Error::NotSupported),
  }
#+END_SRC

for all the functions. The solution adopted here is more elegant. It Implements
a ~map_result~ that applies the given function to the inner ~Terminal~ if it's
present and returns an error otherwise:

#+CAPTION: ~out.rs:217~
#+BEGIN_SRC rust
  impl<T: Terminal + Send> ColoredTerminal<T> {
      fn map_result<F>(&mut self, mut f: F) -> term::Result<()>
          where F: FnMut(&mut T) -> term::Result<()>
      {
          match *self {
              ColoredTerminal::Colored(ref mut w) => f(w),
              ColoredTerminal::NoColor(_) => Err(term::Error::NotSupported),
          }
      }
  }
#+END_SRC

In this way the whole ~Terminal~ implementation is just a bunch of one-liners.

The missing piece of this puzzle is the ~Out~ struct. The comment on top of the
struct speaks for itself:

#+CAPTION: ~out.rs:12~
#+BEGIN_SRC rust
  /// Out controls the actual output of all search results for a particular file
  /// to the end user.
  ///
  /// (The difference between Out and Printer is that a Printer works with
  /// individual search results where as Out works with search results for each
  /// file as a whole. For example, it knows when to print a file separator.)
  pub struct Out {
      #[cfg(not(windows))]
      term: ColoredTerminal<term::TerminfoTerminal<io::BufWriter<io::Stdout>>>,
      #[cfg(windows)]
      term: ColoredTerminal<WinConsole<io::Stdout>>,
      printed: bool,
      file_separator: Option<Vec<u8>>,
  }
#+END_SRC

The implementation is straightforward: whenever ~write~ is called with a
~ColoredTerminal~ as a buffer, it prints a separator (except for the first
file), then prints the buffer contents and then flushes the terminal. Here is
the Unix version:

#+BEGIN_SRC rust
  #[cfg(not(windows))]
  pub fn write(&mut self, buf: &ColoredTerminal<term::TerminfoTerminal<Vec<u8>>>) {
      self.write_sep();
      match *buf {
          ColoredTerminal::Colored(ref tt) => {
              let _ = self.term.write_all(tt.get_ref());
          }
          ColoredTerminal::NoColor(ref buf) => {
              let _ = self.term.write_all(buf);
          }
      }
      self.write_done();
  }
#+END_SRC

A similar but not exactly the same version is provided for Windows, so there is
some code duplication here. It would be better to abstract these details in
~ColoredTerminal~, providing a ~write_all~ method there, or in alternative, to
introduce a new trait used by ~ColoredTerminal~ itself that does the same and
than make ~TerminfoTerminal~, ~WindowsBuffer~ and ~WindowsConsole~ to implement
it.

* Concluding remarks
In this post we have done a little ~ripgrep~ code review, looking at some of the
design decisions made. The review is far from being complete, but my goal was to
look at the patterns and break them down, in hope that they can be used in
similar contexts by other projects. The ~ripgrep~ crate is a beautiful peace of
software, from which the community can learn a lot.

I need to make a side note here about the extensive usage of ~#[inline(always)]~
and ~#[inline(never)]~ directives. I wonder if those have been added after
profiling and if so, why the compiler have failed to identify those correctly. A
possible use case is intra-crate inlining, but compiling with ~rustc -C lto~
already allows to inline everything (by slowing down compilation) (see [[https://internals.rust-lang.org/t/when-should-i-use-inline/598][When
should I use inline]])

That's all folks.
