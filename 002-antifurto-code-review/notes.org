#+TITLE: Antifurto notes

* Overview
There are the following components in Antifurto:
+ =antifurto= executable, written in C++
+ =antifurto.fgci= executable, written in C++
+ the web interface, written in PHP + bootstrap
+ a bash script to send e-mails
+ a bunch of third party python scripts to send whatsapp messages, upload
  pictures to Dropbox.

** Architecture
The design is heavily based on [[https://en.wikipedia.org/wiki/Observer_pattern][observers]], [[https://en.wikipedia.org/wiki/Type_erasure][type erasure]] and the [[https://en.wikipedia.org/wiki/Composition_over_inheritance][composite reuse
principle]], to minimize dependencies among components. Well, at least it was an
attempt I made to implement the project with those principles in mind.

*TODO*: block diagram with the flow of pictures here. Explain the interactions
between live view and monitoring functionalities.

*** Critique on the design
+ Not safe to put everything in the device, included the server part. This has
  been done to avoid external services.

* Antifurto main executable
** Antifurto class
This class is responsible to start and stop the monitoring and the live view,
orchestrating the resources involved. It uses a ~Config~ structure for the
configuration. It can be used as an external library, since it is
self-contained.

It contains a ~MonitorController~, a ~CameraController~ and a
~LiveViewController~.

Interesting stuff:
+ the way it handles start and stop
+ it uses PIMPL pattern to hide all the dependencies to the outside

** MonitorController
This class is the main controller that handls the monitoring functionality. It
delegates to its sub-components tasks such as motion detection, and
notification. Whenever a picture is captured, it is passed along by calling
~examinePicture~:

#+BEGIN_SRC c++
  void examinePicture(const Picture& picture);
#+END_SRC

Whenever some motion is detected, the capture rate is increased, and if the
motion continues, the notifications are fired.

Interesting stuff:
+ it uses two callbacks to ask for a change in the capture rate, and for
  enabling / disabling the capture.

** CameraController
This class is responsible to take pictures from a camera at a given rate. An
user of this class can register an observer and specify the rate at which the
pictures have to be taken. Every time a picture is taken, the observer callback
is called. If multiple observers are interested in different capture rates, the
minimum rate is used. This means that an observer specifies the minimum speed,
not the exact one.

To implement this functionality, in a separate thread a ~Metronome~ class sleeps
the required time, and then the ~Camera~ class takes a picture. Every time an
observer is registered or de-registered, the sleep time is updated.

** Camera
The camera type is statically determined in =StaticConfig.hpp=. In the
Raspberry-Pi case, there is a homegrown version implemented by ~PiCamera~, that
uses a slightly modified version of the =picam= library, that I found [[http://robotblogging.blogspot.nl/2013/10/an-efficient-and-simple-c-api-for.html][here]]. This
library is a simple interface on top of the Raspberry [[https://github.com/mbrt/userland][userland]] library I forked
just to ease the build. To capture images outside the Raspberry world I instead
opted for the [[http://opencv.org/][OpenCV]] library and implemented ~CvCamera~. Now, I have to admit
that the ~CvCaptureRAII~ class might look a bit weird, but it was an attempt to
implement the camera resource through [[https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization][RAII]]. I took inspiration from Martinho
Fernandez [[https://rmf.io/cxx11/rule-of-zero][rule of zero]] blog post and the [[http://scottmeyers.blogspot.nl/2014/03/a-concern-about-rule-of-zero.html][concern about the rule of zero]] by Scott
Meyers. To discuss this in detail I would need an entire blog post in itself, so
I'll just point you to these valuable resources. To be honest I'm not very
satisfied by its look and feel now, so maybe refer to the ~PiCamera~
implementation, it's just a one liner:

#+BEGIN_SRC c++
  std::unique_ptr<CCamera, void(*)(CCamera*)> capture_;
#+END_SRC

It uses the non-so-well-known custom deleter feature of ~std::unique_ptr~.
Again, look at Fernandez post for an explanation on why I didn't just
implemented a stupid destructor for ~PiCamera~.

Since these two different implementations are not intended to be used in the
same codebase, I didn't introduce any common interface, and just used a compile
time define and a ~typedef~ to switch between them:

#+BEGIN_SRC c++
  namespace antifurto {
  namespace config {

  #if defined(ANTIFURTO_RASPBERRY)
      using Camera = antifurto::PiCamera;
  #else
      using Camera = antifurto::CvCamera;
  #endif

  }}
#+END_SRC

The code will simply refer to the ~antifurto::config::Camera~ type to get a
capture resource. I just needed to make sure their public interface (i.e. the
public methods) are the same, so the two classes could be used interchangeably.

** LiveViewController
This class starts and stops the live view functionality. It doesn't implement
the functionality itself; it just controls the lifetime of a ~LiveView~ object.
From the outside it takes pictures and start and stop commands. Whenever a
picture comes, it is forwarded to the internal ~LiveView~ object, which in turn
answer if it has been able to process the picture or not. After a certain
timeout with the live view not progressing, the view is stopped:

#+BEGIN_SRC c++
  if (liveView_->addPicture(p))
      lastPictureWrittenTime_ = system_clock::now();
  else if (system_clock::now() - lastPictureWrittenTime_ > timeout_)
      stop();
#+END_SRC

The ~stop~ function invokes a callback, informing that the live view is not
interested in the stream of pictures anymore.

** LiveView
Tis class is responsible to forward pictures to a [[http://zeromq.org/][ZeroMQ]] socket. It has a single
producer / single consumer queue (see the [[concurrency]] section) and a worker
thread to offload the communication.

Interesting:
+ the queue is a non-blocking lock-free queue, that allows minimum interruption
  for the producer;
+ we use the [[http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive][request-reply pattern]] in ZeroMQ, that allows a simple communication
  between the main executable and the frontend;
+ whenever the queue is full, the images get discarded, and the caller is
  notified. The ~LiveViewController~ timeouts when the queue is full for too
  long and shuts the live view off.

** Homegrown utility libraries
*** meta
This namespace contains some generic patterns and algorithms that do not depend
on the specific details of the project itself. In =Observer.hpp== you can find a
generic implementation of the [[https://en.wikipedia.org/wiki/Observer_pattern][observer pattern]]. A ~Subject~ wants to provide
observers the possibility to register for events. The class takes a variadic
number of type parameters, that will be used in the notification. For example:

#+BEGIN_SRC c++
  Subject<int, float> s;
  auto reg = s.registerObserver([](int a, float b) { print(a, b); });
  s.notify(3, 3.14);
#+END_SRC

in this example we want to notify our observer with an integer and a float. To
do that we just need to declare ~Subject~ with the right parameters. This will
in turn be able to accept observers that respect the ~std::function<void(int,
float)>~ signature.

Interesting:
+ the registration returns a token that when goes out of scope unregisters the
  observer automatically;
+ it is possible to register and unregister observers within notification
  callbacks (re-entrant calls are supported).

Other small utilities are also present, like ~ErasedUniquePtr~, that provides an
unique pointer with an erased deleter. This is an useful workaround to a subtle
problem when you want to forward declare a class and use it in an unique
pointer. For more details see the [[https://akrzemi1.wordpress.com/2013/12/11/type-erasure-part-iii/][type erasure post]] of Andrzej's blog.

*** fs
This namespace contains simple path manipulation utilities to concatenate
multiple paths with a single call:

#+BEGIN_SRC c++
  std::string p = fs::concatPaths("/var/log", bar, "file.txt");
#+END_SRC

*** log
This namespace contains logging utilities. The focus of this library was to
provide a fast and simple logging without using macro shenanigans.

You can use it with a call to a free function, that will return the proper
logger:

#+BEGIN_SRC c++
  log::debug() << "my log here " << 15;
#+END_SRC

There is also a ~reload~ function. When a log rotation occurs it will simply
close the old file (that has been rotated) and open a new file in the same
place. Ignored log levels are implemented by returning a logger that writes to a
~NullSink~, which simply does nothing. Interestingly cryptic is the
implementation of an ~std::outstream~ that does nothing. You can find it in
=log/NullStream.hpp=.

*** concurrency
This namespace contains some classes to deal with concurrency. An interesting
one is ~SpScQueue~, that wraps a worker thread and allows to enqueue work items
for it. The type of the work item is templated, to allow reusability. The queue
is a lock-free implementation that can be chosen at compile time among a
fixed-size and a dynamically allocated one. The former is preferred in case the
maximum queue size is known at compile time.

As a side note I would like to add here that since the project deals with
real-time data, avoiding dynamic allocations can be critical. We used fixed
bound queues in all places for this reason.

Another interesting class is the ~TaskScheduler~ one. It provides the
possibility to schedule tasks at certain time points, ether one-shot or
periodically re-scheduled:

#+BEGIN_SRC c++
  void scheduleAt(Clock::time_point t, Task w);
  void scheduleAfter(Clock::duration d, Task w);
  void scheduleEvery(Clock::duration d, Task w);
#+END_SRC

The work items are processed one after the other in a worker thread, so delays
added by one task impact on the next ones. It is for this reason used only for
short tasks.

*** ipc
*** text
